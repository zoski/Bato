<html>

<head>
    <title>Batô</title>
    <style>
    body {
        margin: 0;
        background-color: #bbbbbb;
        overflow: hidden;
    }

    canvas {
        width: 100%;
        height: 100%;
    }
    </style>
    <meta charset="utf-8">

</head>

<body>
    <!-- THREE JS scripts -->
    <script src="lib/three.js/three.min.js"></script>
    <script src="lib/three.js/Detector.js"></script>
    <script src="lib/three.js/controls/OrbitControls.js"></script>
    <!-- Libs externes -->
    <script src="lib/threex.daynight.js"></script>
    <script src="lib/threex.keyboardstate.js"></script>
    <script src="lib/stats.min.js"></script>
    <!-- https://github.com/mrdoob/stats.js -->


    <!-- Game core et extension -->
    <script src="js/stats.js"></script><!-- https://github.com/mrdoob/stats.js -->

    <script src="js/dayAndNight.js"></script>
    <script src="js/light.js"></script>

    <script>

    var onRenderFcts = []; // stock les fonctions qui doivent être exécuté à chaque rendu
    var dayAndNight = true ;

    init();
    devLight();

    if(dayAndNight) {
        daynight();

    }


    var scene, camera, renderer, controls;
    function init() {

            scene = new THREE.Scene();
            // FOV, Ratio Largeur/ Hauteur , Distance de vue proche , Distance max de vue
            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 5;
            camera.position.y = 2;

            ////////////////////////    Rendu
            renderer = new THREE.WebGLRenderer({
                antialias: true
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            // renderer.setClearColor(new THREE.Color(0xEEEEEE, 1.0));
            // renderer.shadowMapEnabled = true;
            document.body.appendChild(renderer.domElement);

            ////////////////////////    Control camera with the lib OrbitControls
            controls = new THREE.OrbitControls(camera);

            //desactivate pan of the camera
            controls.noPan = true;

            //set camera's distance around the target
            controls.minDistance = 3;
            controls.maxDistance = 10;

            //set angle to unable being under the sea
            controls.minPolarAngle = THREE.Math.degToRad(0);
            controls.maxPolarAngle = THREE.Math.degToRad(95);

            ////////////////////////    Mer
            var sea_material = new THREE.MeshPhongMaterial({
                shading: THREE.SmoothShading,
                color: 0x0092ff, //blue
                side: THREE.DoubleSide
            });

            var sea_geometry = new THREE.PlaneGeometry(1000, 1000);

            var sea = new THREE.Mesh(sea_geometry, sea_material);
            sea.rotateX(Math.PI / 2);

            scene.add(sea);

            ///////////////////////// Batô
            var boat = new THREE.Group();
            scene.add(boat);

            var boat_material = new THREE.MeshPhongMaterial({
                //shading: THREE.SmoothShading,
                //color: 0x0092ff //brown
            });

            var boat_base_geometry = new THREE.BoxGeometry(1, 0.5, 2);
            var boat_base = new THREE.Mesh( boat_base_geometry, boat_material );
            boat_base.position.y = 0.25;
            boat.add( boat_base );

            var boat_mast_geometry = new THREE.BoxGeometry(0.1, 2, 0.1);
            var boat_mast = new THREE.Mesh(boat_mast_geometry, boat_material);
            boat_mast.position.y = 1;
            boat.add( boat_mast );

/*
            boat.add(controls);
            controls.target = new THREE.Vector3(boat.position.x,1,boat.position.z);
            //boat.rotation.y = 10;
            var velocity = new THREE.Vector3(1,1,1);
            var turning = new THREE.Vector2(5,5);
            //hasturned is used to count +1 when left, -1 when right
            //it helps for the trigonometry when you go straight after turning
            var hasturned = 0;
            var canJump;

            //Variable projection Helper:
            var turnCos = Math.cos(THREE.Math.degToRad(turning.x*hasturned));
            var turnSin = Math.sin(THREE.Math.degToRad(turning.y*hasturned));

          var onKeyDown = function ( event ) {

            if(event.keyCode == 38 || event.keyCode == 90){
              controls.target = new THREE.Vector3(boat.position.x,1,boat.position.z);
              boat.position.z -= turnCos;
              boat.position.x -= turnSin;
              camera.position.z -= turnCos;
              camera.position.x -= turnSin;
              console.log("AVANCE !!!");
            }

              if(event.keyCode == 39|| event.keyCode == 68){
                hasturned -= 1;
                controls.target = new THREE.Vector3(boat.position.x,1,boat.position.z);
                boat.rotation.y -= THREE.Math.degToRad(turning.y);
                //boat.position.x += velocity.x;
                //camera.position.x += velocity.x;
                //controls.update();
                turnCos = Math.cos(THREE.Math.degToRad(turning.x*hasturned));
                turnSin = Math.sin(THREE.Math.degToRad(turning.y*hasturned));
                console.log("tourne !!!");
              }

              if(event.keyCode == 37|| event.keyCode == 81){
                      //moveLeft = true;
                      hasturned += 1;
                      controls.target = new THREE.Vector3(boat.position.x,1,boat.position.z);
                      //boat.position.x -= velocity.x;
                      boat.rotation.y += THREE.Math.degToRad(turning.x);
                      //camera.position.x -= velocity.x;
                      //controls.update();
                      turnCos = Math.cos(THREE.Math.degToRad(turning.x*hasturned));
                      turnSin = Math.sin(THREE.Math.degToRad(turning.y*hasturned));
                    }
              };

              document.addEventListener( 'keydown', onKeyDown, false );
*/
    var velocity = new THREE.Vector3(1,1,1);
    var turning = new THREE.Vector2(1,1);
    var hasturned = 0;
    var canJump;

    //Variable projection Helper:
    var turnCos = Math.cos(THREE.Math.degToRad(turning.x*hasturned));
    var turnSin = Math.sin(THREE.Math.degToRad(turning.y*hasturned));

    function updateTurn(){
      //problem if hasturned too much
      turnCos = Math.cos(THREE.Math.degToRad(turning.x*hasturned));
      turnSin = Math.sin(THREE.Math.degToRad(turning.y*hasturned));
    }

  	var keyboard	= new THREEx.KeyboardState(renderer.domElement);
  	renderer.domElement.setAttribute("tabIndex", "0");
  	renderer.domElement.focus();

    onRenderFcts.push(function(delta, now){
  		if( keyboard.pressed('left') || keyboard.pressed('q')){
  			boat.rotation.y += 1 * delta;
        hasturned += 1;
        updateTurn();
  		}else if( keyboard.pressed('right') || keyboard.pressed('d')){
  			boat.rotation.y -= 1 * delta;
        hasturned -= 1;
        updateTurn();
  		}
  		if( keyboard.pressed('down') || keyboard.pressed('s')){
/*        //trigo
        controls.target = new THREE.Vector3(boat.position.x,1,boat.position.z);
        boat.position.z -= turnCos;
        boat.position.x -= turnSin;
        camera.position.z -= turnCos;
        camera.position.x -= turnSin;

  			boat.position.x += 1 * delta;
*/
  		}else if( keyboard.pressed('up') || keyboard.pressed('z')){
        //trigo
        controls.target = new THREE.Vector3(boat.position.x,1,boat.position.z);
        boat.position.z -= turnCos;
        boat.position.x -= turnSin;
        camera.position.z -= turnCos;
        camera.position.x -= turnSin;

  		}
  	})
/*
  	// only on keydown
  	keyboard.domElement.addEventListener('keydown', function(event){
  		if( keyboard.eventMatches(event, 'z') )	boat.scale.y	/= 2
  		if( keyboard.eventMatches(event, 's') )	boat.scale.y	*= 2
  	})
  	// only on keyup
  	keyboard.domElement.addEventListener('keyup', function(event){
  		if( keyboard.eventMatches(event, 'q') )	boat.scale.x	*= 2
  		if( keyboard.eventMatches(event, 'd') )	boat.scale.x	/= 2
  	})
*/

            //////////////////////// Cube taille d'une île
            var island_geo = new THREE.BoxGeometry(5, 1, 5);
            var island_mat = new THREE.MeshLambertMaterial({
                shading: THREE.SmoothShading,
                color: 0xaaaaaa
            });
            var island = new THREE.Mesh(island_geo, island_mat);
            island.position.z = -200;

            scene.add(island);

        } //</init>

    ////////////////// Gestion du temps
    var lastTimeMsec = null;

    onRenderFcts.push(function() {
        renderer.render(scene, camera);
    })

    ///////////////////// Animation
    requestAnimationFrame(function animate(nowMsec) {
        stats.begin();
        // keep looping
        requestAnimationFrame(animate);
        // measure time
        lastTimeMsec = lastTimeMsec || nowMsec - 1000 / 60
        var deltaMsec = Math.min(200, nowMsec - lastTimeMsec)
        lastTimeMsec = nowMsec
            // call each update function
        onRenderFcts.forEach(function(onRenderFct) {
            onRenderFct(deltaMsec / 1000, nowMsec / 1000)
        })

        //controls.update();
        stats.end();
    })
    </script>
</body>

</html>

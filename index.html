<html>

<head>
    <title>Batô</title>
    <style>
    body {
        margin: 0;
        background-color: #bbbbbb;
        overflow: hidden;
    }
    
    canvas {
        width: 100%;
        height: 100%;
    }
    </style>
    <meta charset="utf-8">
</head>

<body>
    <!-- THREE JS scripts -->
    <script src="lib/three.js/three.min.js"></script>
    <script src="lib/three.js/Detector.js"></script>
    <script src="lib/three.js/controls/OrbitControls.js"></script>
    <!-- Libs externes -->
    <script src="lib/threex.daynight.js"></script>
    <script src="lib/stats.min.js"></script>
    <!-- https://github.com/mrdoob/stats.js -->


    <!-- Game core et extension -->
    <script src="js/stats.js"></script><!-- https://github.com/mrdoob/stats.js -->

    <script src="js/dayAndNight.js"></script>
    <script src="js/light.js"></script>

    <script>

    var onRenderFcts = []; // stock les fonctions qui doivent être exécuté à chaque rendu
    var dayAndNight = true ;

    init();
    devLight();

    if(dayAndNight) {
        daynight();
        
    }


    var scene, camera, renderer, controls;
    function init() {

            scene = new THREE.Scene();
            // FOV, Ratio Largeur/ Hauteur , Distance de vue proche , Distance max de vue
            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 5;
            camera.position.y = 2;
            var b = new THREE.Vector3( 0, 10, 0 );
            camera.lookAt(b);
            
            

            ////////////////////////    Rendu
            renderer = new THREE.WebGLRenderer({
                antialias: true
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            // renderer.setClearColor(new THREE.Color(0xEEEEEE, 1.0));
            // renderer.shadowMapEnabled = true;
            document.body.appendChild(renderer.domElement);

            ////////////////////////    Controle caméra
            controls = new THREE.OrbitControls(camera);

            ////////////////////////    Mer
            var sea_material = new THREE.MeshPhongMaterial({
                shading: THREE.SmoothShading,
                color: 0x0092ff, //blue
                side: THREE.DoubleSide
            });

            var sea_geometry = new THREE.PlaneGeometry(1000, 1000);

            var sea = new THREE.Mesh(sea_geometry, sea_material);
            sea.rotateX(Math.PI / 2);

            scene.add(sea);

            ///////////////////////// Batô
            var boat = new THREE.Group();
            scene.add(boat);

            var boat_material = new THREE.MeshPhongMaterial({
                //shading: THREE.SmoothShading,
                //color: 0x0092ff //brown
            });

            var boat_base_geometry = new THREE.BoxGeometry(1, 0.5, 2);
            var boat_base = new THREE.Mesh( boat_base_geometry, boat_material );
            boat_base.position.y = 0.25;
            boat.add( boat_base );

            var boat_mast_geometry = new THREE.BoxGeometry(0.1, 2, 0.1);
            var boat_mast = new THREE.Mesh(boat_mast_geometry, boat_material);
            boat_mast.position.y = 1;
            boat.add( boat_mast );


            //////////////////////// Cube taille d'une île
            var island_geo = new THREE.BoxGeometry(5, 1, 5);
            var island_mat = new THREE.MeshLambertMaterial({
                shading: THREE.SmoothShading,
                color: 0xaaaaaa
            });
            var island = new THREE.Mesh(island_geo, island_mat);
            island.position.z = -200;

            scene.add(island);

        } //</init>

    ////////////////// Gestion du temps
    var lastTimeMsec = null;

    onRenderFcts.push(function() {
        renderer.render(scene, camera);
    })

    ///////////////////// Animation
    requestAnimationFrame(function animate(nowMsec) {
        stats.begin();
        // keep looping
        requestAnimationFrame(animate);
        // measure time
        lastTimeMsec = lastTimeMsec || nowMsec - 1000 / 60
        var deltaMsec = Math.min(200, nowMsec - lastTimeMsec)
        lastTimeMsec = nowMsec
            // call each update function
        onRenderFcts.forEach(function(onRenderFct) {
            onRenderFct(deltaMsec / 1000, nowMsec / 1000)
        })

        controls.update();
        stats.end();
    })
    </script>
</body>

</html>
<html>

<head>
    <title>Batô</title>
    <style>
    body {
        margin: 0;
        background-color: #bbbbbb;
        overflow: hidden;
    }

    canvas {
        width: 100%;
        height: 100%;
    }
    </style>
    <meta charset="utf-8">

</head>

<body>
    <!-- THREE JS scripts -->
    <script src="lib/three.js/three.min.js"></script>
    <script src="lib/three.js/Detector.js"></script>
    <script src="lib/three.js/controls/OrbitControls.js"></script>
    <!-- Libs externes -->
    <script src="lib/threex.daynight.js"></script>
    <script src="lib/stats.min.js"></script>
    <!-- https://github.com/mrdoob/stats.js -->


    <!-- Game core et extension -->
    <script src="js/stats.js"></script><!-- https://github.com/mrdoob/stats.js -->

    <script src="js/dayAndNight.js"></script>
    <script src="js/light.js"></script>

    <script>

    var onRenderFcts = []; // stock les fonctions qui doivent être exécuté à chaque rendu
    var dayAndNight = true ;

    init();
    devLight();

    if(dayAndNight) {
        daynight();

    }


    var scene, camera, renderer, controls;
    function init() {

            scene = new THREE.Scene();
            // FOV, Ratio Largeur/ Hauteur , Distance de vue proche , Distance max de vue
            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 5;
            camera.position.y = 2;

            //var b = new THREE.Vector3( 0, 10, 0 );
            //camera.lookAt(b); //OrbitControls s'en occupe


            ////////////////////////    Rendu
            renderer = new THREE.WebGLRenderer({
                antialias: true
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            // renderer.setClearColor(new THREE.Color(0xEEEEEE, 1.0));
            // renderer.shadowMapEnabled = true;
            document.body.appendChild(renderer.domElement);

            ////////////////////////    Control camera with the lib OrbitControls
            controls = new THREE.OrbitControls(camera);

            //desactivate pan of the camera
            controls.noPan = true;

            //set camera's distance around the target
            controls.minDistance = 3;
            controls.maxDistance = 10;

            //set angle to unable being under the sea
            controls.minPolarAngle = THREE.Math.degToRad(0);
            controls.maxPolarAngle = THREE.Math.degToRad(95);

            ////////////////////////    Mer
            var sea_material = new THREE.MeshPhongMaterial({
                shading: THREE.SmoothShading,
                color: 0x0092ff, //blue
                side: THREE.DoubleSide
            });

            var sea_geometry = new THREE.PlaneGeometry(1000, 1000);

            var sea = new THREE.Mesh(sea_geometry, sea_material);
            sea.rotateX(Math.PI / 2);

            scene.add(sea);

            ///////////////////////// Batô
            var boat = new THREE.Group();
            scene.add(boat);

            var boat_material = new THREE.MeshPhongMaterial({
                //shading: THREE.SmoothShading,
                //color: 0x0092ff //brown
            });

            var boat_base_geometry = new THREE.BoxGeometry(1, 0.5, 2);
            var boat_base = new THREE.Mesh( boat_base_geometry, boat_material );
            boat_base.position.y = 0.25;
            boat.add( boat_base );

            var boat_mast_geometry = new THREE.BoxGeometry(0.1, 2, 0.1);
            var boat_mast = new THREE.Mesh(boat_mast_geometry, boat_material);
            boat_mast.position.y = 1;
            boat.add( boat_mast );


            boat.add(controls);
            controls.target = new THREE.Vector3(boat.position.x,1,boat.position.z);
            //boat.rotation.y = 10;
            var velocity = new THREE.Vector3(1,1,1);
            var turning = new THREE.Vector2(5,5);
            //hasturned is used to count +1 when left, -1 when right
            //it helps for the trigonometry when you go straight after turning
            var hasturned = 0;
            var canJump;

            //Variable projection Helper:
            var turnCos = Math.cos(THREE.Math.degToRad(turning.x*hasturned));
            var turnSin = Math.sin(THREE.Math.degToRad(turning.y*hasturned));

            var onKeyDown = function ( event ) {

              switch ( event.keyCode ) {

                case 38: // up
                case 90: // z
                  controls.target = new THREE.Vector3(boat.position.x,1,boat.position.z);
                  //boat.position.z -= velocity.z;  //MARCHE
                  boat.position.z -= turnCos;
                  boat.position.x -= turnSin;
                  //camera.position.z -= velocity.z;
                  camera.position.z -= turnCos;
                  camera.position.x -= turnSin;
                  //controls.update();
                  break;

                case 37: // left
                case 81: // q
                  //moveLeft = true;
                  hasturned += 1;
                  controls.target = new THREE.Vector3(boat.position.x,1,boat.position.z);
                  //boat.position.x -= velocity.x;
                  boat.rotation.y += THREE.Math.degToRad(turning.x);
                  //camera.position.x -= velocity.x;
                  //controls.update();
                  turnCos = Math.cos(THREE.Math.degToRad(turning.x*hasturned));
                  turnSin = Math.sin(THREE.Math.degToRad(turning.y*hasturned));
                  break;
/*
                //disable: a boat doesnt go back
                case 40: // down
                case 83: // s
                  //moveBackward = true;
                  controls.target = new THREE.Vector3(boat.position.x,1,boat.position.z);
                  boat.position.z += velocity.z;
                  camera.position.z += velocity.z;
                  controls.update();
                  break;
*/
                  case 39: // right
                  case 68: // d
                    //moveRight = true;
                    hasturned -= 1;
                    controls.target = new THREE.Vector3(boat.position.x,1,boat.position.z);
                    boat.rotation.y -= THREE.Math.degToRad(turning.y);
                    //boat.position.x += velocity.x;
                    //camera.position.x += velocity.x;
                    //controls.update();
                    turnCos = Math.cos(THREE.Math.degToRad(turning.x*hasturned));
                    turnSin = Math.sin(THREE.Math.degToRad(turning.y*hasturned));
                    break;
/*
                  //disable for now //jumping
                  case 32: // space
                    if ( canJump === true ) boat.position.y += 2;
                      canJump = false;
                      break;
*/
                }

              };

              document.addEventListener( 'keydown', onKeyDown, false );

            //////////////////////// Cube taille d'une île
            var island_geo = new THREE.BoxGeometry(5, 1, 5);
            var island_mat = new THREE.MeshLambertMaterial({
                shading: THREE.SmoothShading,
                color: 0xaaaaaa
            });
            var island = new THREE.Mesh(island_geo, island_mat);
            island.position.z = -200;

            scene.add(island);

        } //</init>

    ////////////////// Gestion du temps
    var lastTimeMsec = null;

    onRenderFcts.push(function() {
        renderer.render(scene, camera);
    })

    ///////////////////// Animation
    requestAnimationFrame(function animate(nowMsec) {
        stats.begin();
        // keep looping
        requestAnimationFrame(animate);
        // measure time
        lastTimeMsec = lastTimeMsec || nowMsec - 1000 / 60
        var deltaMsec = Math.min(200, nowMsec - lastTimeMsec)
        lastTimeMsec = nowMsec
            // call each update function
        onRenderFcts.forEach(function(onRenderFct) {
            onRenderFct(deltaMsec / 1000, nowMsec / 1000)
        })

        //controls.update();
        stats.end();
    })
    </script>
</body>

</html>
